{"version":3,"sources":["../src/util/async_queue.ts"],"names":[],"mappings":"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","file":"async_queue.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert, fail } from './assert';\nimport * as log from './log';\nimport { AnyDuringMigration, AnyJs } from './misc';\nimport { Deferred } from './promise';\nimport { Code, FirestoreError } from './error';\n\ntype DelayedOperation<T> = {\n  // tslint:disable-next-line:no-any Accept any return type from setTimeout().\n  handle: any;\n  op: () => Promise<T>;\n  deferred: Deferred<T>;\n};\n\nexport class AsyncQueue {\n  // The last promise in the queue.\n  private tail: Promise<AnyJs | void> = Promise.resolve();\n\n  // A list with timeout handles and their respective deferred promises.\n  // Contains an entry for each operation that is queued to run in the future\n  // (i.e. it has a delay that has not yet elapsed). Prior to cleanup, this list\n  // may also contain entries that have already been run (in which case `handle` is\n  // null).\n  private delayedOperations: DelayedOperation<AnyJs>[] = [];\n\n  // The number of operations that are queued to be run in the future (i.e. they\n  // have a delay that has not yet elapsed). Unlike `delayedOperations`, this\n  // is guaranteed to only contain operations that have not yet been run.\n  //\n  // Visible for testing.\n  delayedOperationsCount = 0;\n\n  // visible for testing\n  failure: Error;\n\n  // Flag set while there's an outstanding AsyncQueue operation, used for\n  // assertion sanity-checks.\n  private operationInProgress = false;\n\n  /**\n   * Adds a new operation to the queue. Returns a promise that will be resolved\n   * when the promise returned by the new operation is (with its value).\n   *\n   * Can optionally specify a delay (in milliseconds) to wait before queuing the\n   * operation.\n   */\n  schedule<T>(op: () => Promise<T>, delay?: number): Promise<T> {\n    if (this.failure) {\n      fail(\n        'AsyncQueue is already failed: ' +\n          (this.failure.stack || this.failure.message)\n      );\n    }\n\n    if ((delay || 0) > 0) {\n      this.delayedOperationsCount++;\n      const delayedOp: DelayedOperation<T> = {\n        handle: null,\n        op: op,\n        deferred: new Deferred<T>()\n      };\n      delayedOp.handle = setTimeout(() => {\n        this.scheduleInternal(() => {\n          return delayedOp.op().then(result => {\n            delayedOp.deferred.resolve(result);\n          });\n        });\n        delayedOp.handle = null;\n\n        this.delayedOperationsCount--;\n        if (this.delayedOperationsCount === 0) {\n          this.delayedOperations = [];\n        }\n      }, delay);\n      this.delayedOperations.push(delayedOp);\n      return delayedOp.deferred.promise;\n    } else {\n      return this.scheduleInternal(op);\n    }\n  }\n\n  private scheduleInternal<T>(op: () => Promise<T>): Promise<T> {\n    this.tail = this.tail.then(() => {\n      this.operationInProgress = true;\n      return op()\n        .catch(error => {\n          this.failure = error;\n          this.operationInProgress = false;\n          const message = error.stack || error.message || '';\n          log.error('INTERNAL UNHANDLED ERROR: ', message);\n\n          // Escape the promise chain and throw the error globally so that\n          // e.g. any global crash reporting library detects and reports it.\n          // (but not for simulated errors in our tests since this breaks mocha)\n          if (message.indexOf('Firestore Test Simulated Error') < 0) {\n            setTimeout(() => {\n              throw error;\n            }, 0);\n          }\n\n          // Re-throw the error so that this.tail becomes a rejected Promise and\n          // all further attempts to chain (via .then) will just short-circuit\n          // and return the rejected Promise.\n          throw error;\n        })\n        .then(() => {\n          this.operationInProgress = false;\n        });\n    });\n    return this.tail as AnyDuringMigration;\n  }\n\n  /**\n   * Verifies there's an operation currently in-progress on the AsyncQueue.\n   * Unfortunately we can't verify that the running code is in the promise chain\n   * of that operation, so this isn't a foolproof check, but it should be enough\n   * to catch some bugs.\n   */\n  verifyOperationInProgress(): void {\n    assert(\n      this.operationInProgress,\n      'verifyOpInProgress() called when no op in progress on this queue.'\n    );\n  }\n\n  /**\n   * Waits until all currently scheduled tasks are finished executing. Tasks\n   * scheduled with a delay can be rejected or queued for immediate execution.\n   */\n  drain(executeDelayedTasks: boolean): Promise<void> {\n    this.delayedOperations.forEach(entry => {\n      if (entry.handle) {\n        clearTimeout(entry.handle);\n        if (executeDelayedTasks) {\n          this.scheduleInternal(entry.op).then(\n            entry.deferred.resolve,\n            entry.deferred.reject\n          );\n        } else {\n          entry.deferred.reject(\n            new FirestoreError(\n              Code.CANCELLED,\n              'Operation cancelled by shutdown'\n            )\n          );\n        }\n      }\n    });\n    this.delayedOperations = [];\n    this.delayedOperationsCount = 0;\n    return this.schedule(() => Promise.resolve());\n  }\n}\n"]}