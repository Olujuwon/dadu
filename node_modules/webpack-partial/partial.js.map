{"version":3,"sources":["lib/partial.js"],"names":[],"mappings":";;;;;;;;;;;AAAA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;;AAGA,IAAM,SAAS,UAAf;;AAEA,IAAM,QAAQ,SAAR,KAAQ,CAAC,GAAD,EAAM,GAAN,EAAc;AAC1B,MAAI,QAAO,GAAP,yCAAO,GAAP,OAAe,QAAf,IAA2B,QAAO,GAAP,yCAAO,GAAP,OAAe,QAA9C,EAAwD;AACtD,wBACK,GADL,EAEK,GAFL;AAID;AACD,SAAO,GAAP;AACD,CARD;;AAUA,IAAM,OAAO,SAAP,IAAO,CAAC,KAAD,EAAW;AACtB,SAAO,0BAAW,KAAX,KAAsB,SAAS,2BAAY,MAAM,IAAlB,CAA/B,GACL,MADK,GACI,MAAM,IADjB;AAED,CAHD;;AAKO,IAAM,4BAAU,SAAV,OAAU,GAAa;AAAA,oCAAT,IAAS;AAAT,QAAS;AAAA;;AAClC,SAAO,qCACF,IADE,SAEL,UAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,MAAhB,EAAwB,MAAxB,EAAmC;;;;;;AAMjC,QAAI,QAAQ,GAAZ,EAAiB;AACf,aAAO,GAAP;AACD,KAFD,MAEO,IAAI,QAAQ,OAAR,IAAmB,QAAQ,OAAO,KAAtC,EAA6C;AAClD,aAAO,MAAM,GAAN,EAAW,GAAX,CAAP;AACD,KAFM,MAEA,IAAI,uBAAQ,GAAR,KAAgB,uBAAQ,GAAR,CAApB,EAAkC;AACvC,aAAO,sBAAO,uBAAQ,IAAI,MAAJ,CAAW,GAAX,CAAR,EAAyB,IAAzB,CAAP,EAAuC,UAAC,KAAD,EAAQ,KAAR,EAAe,IAAf,EAAwB;AACpE,eAAO,SAAS,MAAT,GACL,MAAM,MAAN,CAAa,4CAAW,KAAX,EAAb,CADK,GAC6B,MAAM,MAAN,iCAAgB,KAAhB,EADpC;AAED,OAHM,EAGJ,EAHI,CAAP;AAID;AACD,WAAO,SAAP;AACD,GAnBI,GAAP;AAqBD,CAtBM;;AAwBA,IAAM,gCAAY,SAAZ,SAAY,CAAC,IAAD,EAAO,KAAP,EAAiB;AACxC,MAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC7B,UAAM,IAAI,SAAJ,CAAc,4BAAd,CAAN;AACD,GAFD,MAEO,IAAI,OAAO,KAAP,KAAiB,UAArB,EAAiC;AACtC,WAAO,MAAM,IAAN,CAAP;AACD;AACD,SAAO,KAAP;AACD,CAPM;;kBASQ,YAAa;AAAA,qCAAT,IAAS;AAAT,QAAS;AAAA;;AAC1B,SAAO,KAAK,MAAL,CAAY,UAAC,IAAD,EAAO,KAAP,EAAiB;AAClC,WAAO,QAAQ,IAAR,EAAc,UAAU,IAAV,EAAgB,KAAhB,CAAd,CAAP;AACD,GAFM,EAEJ,EAFI,CAAP;AAGD,C","file":"partial.js","sourcesContent":["import merge from 'lodash/mergeWith';\nimport isArray from 'lodash/isArray';\nimport isFunction from 'lodash/isFunction';\nimport isUndefined from 'lodash/isUndefined';\nimport reduce from 'lodash/reduce';\nimport groupBy from 'lodash/groupBy';\n\n// TODO: Why does `Symbol()` not work for this?\nconst unique = '___uniq!';\n\nconst entry = (dst, src) => {\n  if (typeof dst === 'object' && typeof src === 'object') {\n    return {\n      ...dst,\n      ...src,\n    };\n  }\n  return src;\n};\n\nconst name = (entry) => {\n  return isFunction(entry) || (entry && isUndefined(entry.name)) ?\n    unique : entry.name;\n};\n\nexport const inherit = (...args) => {\n  return merge(\n    ...args,\n    (dst, src, key, object, source) => {\n      // Short-circuit same-assigns that have already been merged.\n      // Treat entry specially since order is important we can't go just\n      // randomly appending things.\n      // Treat arrays with objects that have the `name` property specially;\n      // entries with identical names will be merged.\n      if (dst === src) {\n        return dst;\n      } else if (key === 'entry' && src === source.entry) {\n        return entry(dst, src);\n      } else if (isArray(dst) && isArray(src)) {\n        return reduce(groupBy(dst.concat(src), name), (items, group, name) => {\n          return name !== unique ?\n            items.concat(inherit(...group)) : items.concat(...group);\n        }, []);\n      }\n      return undefined;\n    }\n  );\n};\n\nexport const normalize = (conf, entry) => {\n  if (typeof entry === 'string') {\n    throw new TypeError('Cannot `require` partials.');\n  } else if (typeof entry === 'function') {\n    return entry(conf);\n  }\n  return entry;\n};\n\nexport default (...args) => {\n  return args.reduce((conf, entry) => {\n    return inherit(conf, normalize(conf, entry));\n  }, { });\n};\n"]}