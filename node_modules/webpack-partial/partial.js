'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalize = exports.inherit = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _mergeWith = require('lodash/mergeWith');

var _mergeWith2 = _interopRequireDefault(_mergeWith);

var _isArray = require('lodash/isArray');

var _isArray2 = _interopRequireDefault(_isArray);

var _isFunction = require('lodash/isFunction');

var _isFunction2 = _interopRequireDefault(_isFunction);

var _isUndefined = require('lodash/isUndefined');

var _isUndefined2 = _interopRequireDefault(_isUndefined);

var _reduce = require('lodash/reduce');

var _reduce2 = _interopRequireDefault(_reduce);

var _groupBy = require('lodash/groupBy');

var _groupBy2 = _interopRequireDefault(_groupBy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

// TODO: Why does `Symbol()` not work for this?
var unique = '___uniq!';

var entry = function entry(dst, src) {
  if ((typeof dst === 'undefined' ? 'undefined' : _typeof(dst)) === 'object' && (typeof src === 'undefined' ? 'undefined' : _typeof(src)) === 'object') {
    return _extends({}, dst, src);
  }
  return src;
};

var name = function name(entry) {
  return (0, _isFunction2.default)(entry) || entry && (0, _isUndefined2.default)(entry.name) ? unique : entry.name;
};

var inherit = exports.inherit = function inherit() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return _mergeWith2.default.apply(undefined, args.concat([function (dst, src, key, object, source) {
    // Short-circuit same-assigns that have already been merged.
    // Treat entry specially since order is important we can't go just
    // randomly appending things.
    // Treat arrays with objects that have the `name` property specially;
    // entries with identical names will be merged.
    if (dst === src) {
      return dst;
    } else if (key === 'entry' && src === source.entry) {
      return entry(dst, src);
    } else if ((0, _isArray2.default)(dst) && (0, _isArray2.default)(src)) {
      return (0, _reduce2.default)((0, _groupBy2.default)(dst.concat(src), name), function (items, group, name) {
        return name !== unique ? items.concat(inherit.apply(undefined, _toConsumableArray(group))) : items.concat.apply(items, _toConsumableArray(group));
      }, []);
    }
    return undefined;
  }]));
};

var normalize = exports.normalize = function normalize(conf, entry) {
  if (typeof entry === 'string') {
    throw new TypeError('Cannot `require` partials.');
  } else if (typeof entry === 'function') {
    return entry(conf);
  }
  return entry;
};

exports.default = function () {
  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  return args.reduce(function (conf, entry) {
    return inherit(conf, normalize(conf, entry));
  }, {});
};
//# sourceMappingURL=partial.js.map